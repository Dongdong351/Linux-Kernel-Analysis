- ### `monolithic kernel`과 `micro kernel`의 차이점은 무엇이고, 각각의 장단점은 무엇인가? 그리고, __리눅스__ 는 둘 중 어디에 가까운가?

    - #### monolithic kernel
        - ##### 장점
            - 커널의 소스 코드 전체가 동일한 커널 메모리 공간에 적재된다. 따라서 커널 내에서 함수를 호출할 때 따로 통신을 할 필요가 없어 성능면에서 마이크로보다 우수할 수 있다. 
            - 커널 공간에 모든 기능들이 적재되어 있으므로, 문맥 교환 비용이 들지 않는다.
        - ##### 단점
            - 커널의 소스 코드 전체가 커다란 정적 바이너리 형태로 디스크에 존재하기 때문에, 커널 모드에서 수행되는 코드의 크기가 마이크로보다 크다. 따라서 큰 메모리 용량을 필요로 한다.
            - 커널 자체가 단일 프로세스이다보니 커널의 모듈화를 제공한 마이크로 커널보다 유지보수가 어려울 수 있고, 특정 부분의 문제가 커널 전체의 문제가 될 수 있다.

    - #### micro kernel
        - ##### 장점
            - `monolithic kernel`은 커널의 많은 기능들이 커널 공간에서 실행되므로, 실시간 프로세스가 일반적인 시스템 호출에 의해 방해 받을 가능성이 높다. 그에 반해 `micro kernel`은 커널의 여러 기능을 커널 공간이 아닌 사용자 공간에서 사용자 애플리케이션처럼 동작하게끔 제공하므로, 높은 우선순위를 가진 실시간 프로세스가 `CPU`를 차지할 기회를 쉽게 얻을 수 있다.
            - 커널의 모듈화로 유지보수가 용이하고, 특정 프로세스의 문제가 커널 전체의 문제가 되지 않는다. 
            - 필요에 따라 동적으로 모듈화된 프로세스를 로드, 삭제할 수 있으므로 유연하다.
            - 커널 공간의 소스 크기가 작아 임베디드에 사용하기 좋다.
        - ##### 단점
            - 프로세스 간 통신에 `IPC`를 사용해야 하므로, `monolithic kernel`와는 다르게 통신을 위한 부가 작업이 필요하다.
            - 사용자 공간 <-> 커널 공간 간 문맥 교환 비용이 발생한다.

    - #### 리눅스는 어디에 가까운가?
        리눅스는 기본적으로 `monolithic kernel`이다. 그러나 자유의 몸인 리눅스는 `micro kernel`의 여러 장점들 또한 가져왔다. 즉, 리눅스는 기본적인 `monolithic kernel`구조에 더해, 모듈화 설계, 선점형, 모듈 동적 로드 등 여러 기능을 추가했다. 

        > 리눅스는 monolithic kernel이지만, micro kernel의 여러 장점들을 가져왔다.

- ### 리눅스가 `Unix like (유닉스와 비슷하면서 유닉스가 아니다)`이라고 불리는 이유는 무엇인가?

    - #### `UNIX`와 비슷한 이유
        - 리눅스는 유닉스의 여러 설계 철학 *(Small is beautiful.)* 을 계승하고, 유닉스의 표준인 __POSIX(유닉스 API)__ 를 만족한다.

    - #### `UNIX` 아닌 이유
        리눅스는 여타 유닉스 시스템과는 달리, 유닉스 소스를 그대로 물려받지 않았다. 리눅스는 특정한 유닉스를 기반으로 구현되지 않았기 때문에, 탄력적으로 가장 좋은 해결책들을 선택해 적용할 수 있었다. 경우에 따라서는 새로운 해결책을 고안하기도 했다.

        - 전통 유닉스는 `monolithic kernel`이다. 그에 반해 리눅스는 기본적인 `monolithic kernel`에 모듈의 동적 로딩 기능을 추가했다.
        - 전통적인 유닉스와는 다르게, 리눅스는 __SMP__ 를 지원한다.
        - 전통적인 유닉스와는 다르게, 리눅스는 __선점형__ 이다.
        - 리눅스는 프로세스와 스레드를 구분하지 않는고, 모두 동등한 프로세스로 간주한다. 다만, 자원을 공유하는 프로세스가 있을 뿐이다.

- ### 커널 메모리는 왜 __페이징 기능__ 을 사용할 수 없는가? 
    __페이징__ 은 __가상 메모리__ 에서 사용하는 기법이며, 가상 주소 공간을 동일한 크기의 __페이지__ 로 나누는 것이다. 이후 __페이지__ 는 `MMU`에 의해 물리 메모리의 __프레임__ 과 맵핑된다. 이러한 과정을 관장하는 게 __커널(운영체제)__ 이다. 그런데 __커널__ 이 자기 자신을 __페이징__ 하는 것이 가능할까? <br><br>
    하나의 예시로, 커널에서는 부동소수점 연산을 간편하게 처리할 수 없다. 사용자 애플리케이션은 부동소수점 연산을 해야 할 때, 커널에게 `트랩`을 보낸다. 커널은 `트랩`을 받으면 연산 모드를 부동소수점 모드로 바꾼다. 그러나 커널은 자신의 `트랩`을 받을 수 없기 때문에, 부동소수점 연산 시 복잡한 과정을 수행하게 된다. <br><br>
    위의 예시에서 볼 수 있듯이, 커널 메모리를 __페이징__ 하지 못하는 이유 또한 `MMU`와 __가상 메모리__, __페이징__ 기능을 담당하는 커널이 자신의 메모리를 __페이징__ 하는 것이 번거로워서 그런 것이라고 판단했다. 이 주제에 대한 토론 후 아직 해결되지 않는 궁금증이 남아있었다. 

> 커널 메모리가 __페이징 기능__ 을 사용할 수 없다는 것은, 기술적으로 구현이 불가하다는 의미일까, 아니면 구현이 가능하더라도 사용하는 것을 금지한다는 의미일까? 

- ### `SMP`의 확장성이 낮은 이유는 무엇인가?
    `SMP`는 컴퓨터의 자원을 여러 프로세서가 동등한 입장에서 접근할 수 있다. 따라서 프로세서의 개수를 늘리면 특정 한도까지는 성능을 끌어올릴 수 있을 것이다. 그러나 한도에 다다른 상태에서 프로세서 개수가 늘어난다면, 모든 프로세서들은 공통의 자원을 공유하기 때문에, 대기 시간이 길어지고 충돌이 발생할 가능성이 높다. 따라서 `MPP`보다 확장성이 낮다. 이는 `Scale Up`과 `Scale Out`의 개념과도 유사하다고 생각할 수 있다.